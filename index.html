<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Shockwave.io</title>
        <style>
        #myCanvas {
          position: absolute;
          left: 55px;
          border:1px solid #505050;
        }
        #textBlock {
          position: absolute;
          left:1000px
        }
        #messages {
          overflow:auto;
          width:200px;
          height:450px;
        }
        h1 {
        }

        </style>
        <script src="/socket.io/socket.io.js"></script>


    </head>


    <body>

        <h1></h1>


        <canvas id="myCanvas" width="890" height="500">
          Your browser does not support the HTML5 canvas tag.
        </canvas>



        <script>

//https://stackoverflow.com/questions/5203407/how-to-detect-if-multiple-keys-are-pressed-at-once-using-javascript

var canvasWidth = 890;
var canvasHeight = 500;

var keyMap = {};
onkeydown = onkeyup = function(e){
    e = e || event;
    keyMap[e.keyCode] = e.type == 'keydown';
}



var holes = [];
var characterDatas = new Map();
var shockwaves = new Map();
var myID = -1;
var myCharacter;
var mouseX = 0;
var mouseY = 0;
var c = document.getElementById("myCanvas");


//from https://nerdparadise.com/programming/javascriptmouseposition
function updateMouse(mouseEvent) {
  var obj = document.getElementById("myCanvas");

  var obj_left = 0;
  var obj_top = 0;
  var xpos;
  var ypos;
  while (obj.offsetParent)
  {
    obj_left += obj.offsetLeft;
    obj_top += obj.offsetTop;
    obj = obj.offsetParent;
  }
  if (mouseEvent)
  {
    //FireFox
    xpos = mouseEvent.pageX;
    ypos = mouseEvent.pageY;
  }
  else
  {
    //IE
    xpos = window.event.x + document.body.scrollLeft - 2;
    ypos = window.event.y + document.body.scrollTop - 2;
  }
  xpos -= obj_left;
  ypos -= obj_top;
  mouseX = xpos;
  mouseY = ypos;
}

function CharacterData(id, name, x, y, z, r, score, velocity) {
  this.id = id;
  this.x = -1000;
  this.y = y;
  this.z = z;
  this.r = r;
  this.prevR = r;
  this.name = name;
  this.score = score;
  this.vx = 0;
  this.vy = 0;
  this.vz = 0;
  this.velocity = velocity;
  this.onGround = true;
  this.life = 100;
  this.reload = 0;
  this.reloadSpeed = 0.1;
  this.angleWidth = 80;
}

CharacterData.prototype.display = function(ctx, x, y) {
  var scaleSize = 1 + this.z;
  var shift = 3 + (this.z) * 20;
  ctx.save();
  ctx.translate(x, y);
  ctx.save();
  ctx.translate(1 + shift, -1 - shift);
  ctx.rotate(this.r);
  ctx.beginPath();
  ctx.rect(-10,-10, 20 * scaleSize, 20 * scaleSize);

  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fill();
  ctx.restore();
  ctx.save();
  ctx.rotate(this.r);
  ctx.beginPath();
  ctx.rect(-10,-10, 20 * scaleSize, 20 * scaleSize);
  ctx.strokeStyle = 'rgba(0,0,0,0.7)';
  ctx.fillStyle = 'rgba(255,255,2355,1)';
  ctx.fill();
  ctx.stroke();
  ctx.restore();
  ctx.font = "20px Arial";
  ctx.strokeText(this.name, - 20, - 34);
  ctx.restore();
};

CharacterData.prototype.acceptPositionUpdate = function(x, y, z, r, vel) {
  this.x = x;
  this.y = y;
  this.z = z;
  this.r = r;
  this.velocity = vel;
  this.onGround = (z <= 0);
}

CharacterData.prototype.acceptStatsUpdate = function(score, life) {
  this.score = score;
  this.life = life;
};

CharacterData.prototype.movement = function() {
    this.r = Math.atan2(mouseY - canvasHeight / 2, mouseX - canvasWidth / 2);
    this.reload += this.reloadSpeed;
    this.slowDownVertical();
    this.slowDownHorizontal();
    if (keyMap[87]) {
      this.moveUp();
    }
    if (keyMap[83]) {
      this.moveDown();
    }
    if (keyMap[65]) {
      this.moveLeft();
    }
    if (keyMap[68]) {
      this.moveRight();
    }

    if (keyMap[32] && this.onGround) {
        this.onGround = false;
        this.vz = 0.06;
    }

    if (!this.onGround) {
        this.vz -= 0.003;
        this.z += this.vz;
    }
    if (this.z < 0) {
        this.z = 0;
        this.vz = 0;
        this.onGround = true;
    }


    this.x += this.vx;
    this.y += this.vy;


    if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01 || this.prevR != this.r){
        this.sendPositionToServer();
    }

    if (this.prevR != this.r) {
      this.prevR = this.r;
    }
}

CharacterData.prototype.sendPositionToServer = function  () {
  socket.emit('update position', this.id, this.x, this.y, this.z, this.r);
}

CharacterData.prototype.slowDownHorizontal = function() {
  if (Math.abs(this.vx) > 0.01){
      this.vx *= 0.9;
  } else {
      this.vx = 0;
  }
}

CharacterData.prototype.slowDownVertical = function() {
  if (Math.abs(this.vy) > 0.01){
      this.vy *= 0.9;
  } else {
      this.vy = 0;
  }
}

CharacterData.prototype.moveUp = function() {
  this.vy += (-this.velocity - this.vy) / 10;

}

CharacterData.prototype.moveDown = function() {
  this.vy += (this.velocity - this.vy) / 10;
}

CharacterData.prototype.moveLeft = function() {
  this.vx += (-this.velocity - this.vx) / 10;
}

CharacterData.prototype.moveRight = function() {
  this.vx += (this.velocity - this.vx) / 10;
}


//id, shockwaveID, x, y, angle, angleWidth, velocity, transparency, tV
function Shockwave (id, shockwaveID, x, y, angle, angleWidth, velocity, transparency, tV) {
    this.angle = angle;
    this.width = 0;
    this.angleWidth = 30;
    this.x=x;
    this.y=y;
    this.velocity = velocity;
    this.transparency = transparency;
    this.transparencyV = tV;
    this.width = 0;
    this.id = id;
    this.shockwaveID = shockwaveID;
}
Shockwave.prototype.display = function(ctx) {
  ctx.save();
  ctx.beginPath();
  ctx.translate(this.x, this.y);
  ctx.rotate(this.angle - this.angleWidth / 2);
  ctx.arc(0,0, this.width, 0, this.angleWidth / 180 * Math.PI);
  ctx.stroke();
  ctx.restore();
}
Shockwave.prototype.acceptPositionUpdate = function(angle, angleWidth, width, transparency){
  this.width = width;
  this.angle = angle;
  this.angleWidth = angleWidth;
  this.transparency = transparency;
}


var Hole = function (x, y, size) {
    this.x = x;
    this.y = x;
    this.size = size;
};
Hole.prototype.display = function(ctx) {
  ctx.save();
  ctx.beginPath();
  ctx.translate(this.x, this.y);
  ctx.arc(0,0, this.size, this.size, 0, 2 * Math.PI);
  ctx.fillStyle = "black";
  ctx.fill();
  ctx.restore();
};
/**
VICTORIA start
*/



/**
VICTORIA end
*/



/**
* Socket.io connection handler portion BEGINS
*/

var updated = false;

var socket = io.connect('localhost:40378');
socket.on('message', function(message) {
    document.getElementById("messages").innerHTML += message +"<br/>";
});


socket.on('init synchronization',function(id) {
  myID = id;
});

socket.on('set user myCharacter', function(bool) {
    myCharacter = characterDatas.get(myID);
});

//for updating a character on the client side when the character may
//not have been constructed yet
socket.on('update new character', function(id, name, x, y, z, r, vel, score) {

  //try to get the character in the map with this id
  var currentCharacter = characterDatas.get(id);

  //if there is no such character, make new
  if (currentCharacter == null)
  {
      characterDatas.set(id, new CharacterData(id, name, x, y, z, r, vel, score));
  } else {

      currentCharacter.score = score;
      currentCharacter.acceptPositionUpdate(x, y, z, r, vel);
  }
});

//for updating a character stats on the client side when it's already initialized
//stats: weapon stats, score,
socket.on('update stats', function(id, score, life) {

  var currentCharacter = characterDatas.get(id);
  if (currentCharacter != null)
  {
    currentCharacter.acceptStatsUpdate(score, life);
  }
});
//for updating a character stats on the client side when it's already initialized
//stats: weapon stats, score,
socket.on('update position', function(id, x, y, z, r, vel) {

  if (id == myID && this.x != -1000) {
    return;
  }
  var currentCharacter = characterDatas.get(id);
  if (currentCharacter != null)
  {
    currentCharacter.acceptPositionUpdate(x, y, z, r, vel);
  }
});

socket.on("confirm updated", function(str) {
  updated = true;
});



socket.on("delete user", function(id) {
  characterDatas.delete(id);
});

socket.on("add hole", function(x,y,size) {
  holes.push(new Hole(x, y, size));
});

//s.id, s.x, s.y, s.angle, s.width, s.velocity, s.transparencyV
socket.on("update shockwave", function(id, shockwaveID, x, y, angle, angleWidth, width, velocity, transparency, tV){
  var s = shockwaves.get(id);
  if (s == null) {
    //function Shockwave (id, x, y, angle, width, velocity, tV) {
    shockwaves.set(id, new Map());
  }
  s = shockwaves.get(id);
  if (s.get(shockwaveID) == null){
    s.set(shockwaveID, new Shockwave(id, shockwaveID, x, y, angle, angleWidth, velocity, transparency, tV));
  }

  var currentShockwave = s.get(shockwaveID);
  currentShockwave.acceptPositionUpdate(angle, angleWidth, width, transparency);

});

socket.on("kill shockwave", function(id, shockwaveID) {
    shockwaves.get(id).delete(shockwaveID);
});

/**VICTORIA start*/

/**VICTORIA end*/

var givenName = false;
function sendStuff() {

    var x = document.getElementById("inputbox").value;
    if (x == "") {
      return;
    }
    if (givenName) {
        socket.emit("message", x);
    } else {
        socket.emit("name", x);
        document.getElementById("button").innerHTML = "Enter Message";
        givenName = true;
    }
    document.getElementById("inputbox").value = "";


}


/**Socket.io connection handler portion ENDS*/


//should be updated == TRUE, temporarily this
function drawCanvas () {
      var ctx = c.getContext("2d");
      ctx.beginPath();
      ctx.rect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = "white";
      ctx.fill();

      ctx.font = "30px Arial";

      ctx.save();
      ctx.translate(canvasWidth/2 - myCharacter.x, canvasHeight/2 - myCharacter.y);


      for (var i = 0; i < holes.length; i++) {
        holes[i].display(ctx);
      }


      //ctx.fillText("Hello I'm a test canvas", 10, 50);
      for (let [k, c] of characterDatas) {
        if (k != myID) {
          c.display(ctx, c.x, c.y);
        }
      }
      ctx.restore();

      ctx.save();
      myCharacter.display(ctx, canvasWidth / 2, canvasHeight / 2);
      ctx.restore();


      ctx.save();
      ctx.translate(canvasWidth/2 - myCharacter.x, canvasHeight/2 - myCharacter.y);
      //display all shockwaves
      for (let [k, v] of shockwaves){
          ctx.save();
          for (let [ks, s] of v){
            s.display(ctx);
          }
          ctx.restore();
      }
      ctx.restore();

      /**VICTORIA start*/

      /**VICTORIA end*/

      ctx.font = "20px Arial";

      ctx.strokeText("holes length:"+holes.length, 30,30);

}

function incrementScore(){
    characterDatas.get(myID).score += 3;
    socket.emit("update stats", myID, myCharacter.score, myCharacter.life);
}

function requestShockwave() {
    if (myCharacter.reload > 1 && myCharacter.onGround){
      myCharacter.reload = 0;
      //id, x, y, angle, angleWidth, velocity, tV
      socket.emit("add shockwave", myID, myCharacter.x, myCharacter.y, myCharacter.r + 2.21, myCharacter.angleWidth, 10, 5);

      //shockwaves.set(myID, new Shockwave());
    }

}

document.getElementById("myCanvas").addEventListener("click", requestShockwave, false);



document.addEventListener('keydown', function(event) {
});

function gameSingleFrame() {
    drawCanvas();
    if (characterDatas.get(myID) != null) {
      characterDatas.get(myID).movement();
    }

}

setInterval(gameSingleFrame, 24);


function getStats() {
  alert("Character data length: " + characterDatas.size + "\n");
  for (let [k, v] of characterDatas){
    alert("character with id" + k + ": "+ v.x + ", " + v.y + "," + v.score);
  }
}

document.getElementById("myCanvas").onmousemove = updateMouse;

        </script>


        <div id="textBlock">
        <input id="inputbox" type="text" name="inputText" value="" autocomplete="off"><br>

        <button id="button" onClick=sendStuff()>Input your name</button>
        <div id="messages"></div>
      </div>
      <script>
      document.getElementById("inputbox").addEventListener("keyup", function(event) {
         if (event.keyCode == '13') {
           sendStuff();
         }
      });
      </script>


    </body>

</html>
